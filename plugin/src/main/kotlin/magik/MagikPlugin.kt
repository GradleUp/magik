/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package magik

import org.gradle.api.Action
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.dsl.RepositoryHandler
import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.artifacts.repositories.RepositoryContentDescriptor
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.services.BuildService
import org.gradle.api.services.BuildServiceParameters
import org.gradle.kotlin.dsl.getByName
import org.http4k.client.JavaHttpClient
import org.http4k.core.*
import org.http4k.core.Method.*
import java.io.File
import java.net.URI
import java.util.*


//abstract class MagikPluginExtension(var repo: File)

abstract class GithubContainer : BuildService<GithubContainer.Params>, AutoCloseable {

    internal interface Params : BuildServiceParameters {
        val repositories: Property<ArrayList<GithubArtifactRepository>>
    }

    init {
        parameters.repositories.set(ArrayList())
    }
}

lateinit var githubContainer: Provider<GithubContainer>

// reference in order to loop and detect automatically the publishing task to append logic to
val githubs = ArrayList<GithubArtifactRepository>()

// project reference in order to automatically set as default, a `repo` directory in the build one
lateinit var configuringProject: Project

/**
 * A simple 'hello world' plugin.
 */
class MagikPlugin : Plugin<Project> {

    override fun apply(project: Project) {

//                println(project)

        // Register the service
        githubContainer = project.gradle.sharedServices.registerIfAbsent("githubContainer", GithubContainer::class.java) {}


        configuringProject = project

        //        if(project.displayName.startsWith("root project '"))
//        githubs.clear()

//        println("a")
        // Add the 'greeting' extension object
        //        project.extensions.create<MagikPluginExtension>("magik", project.layout.buildDirectory.dir("repo").get().asFile)

        // Register a task
        project.tasks.register("greeting") {
            doLast {
                println("Hello from plugin 'magik.greeting'")
            }
        }

        //        println(project.tasks.rules.size)
        //        println(githubs.size)
        //        if (!configured)
        project.tasks.addRule("rule") {
            //            configured = true
                        println("addRule, $this")
            project.tasks.all {
                if (name.startsWith("publish"))
                    for (gh in githubContainer.get().parameters.repositories.get())
                        if (name.endsWith("PublicationTo${gh.name.capitalize()}Repository")) {
                            //                            println("$this, $name")
                            doLast {
                                //                                println(project.displayName)

                                operator fun Method.invoke(relativeUri: String, debugRequest: Boolean = false,
                                                           debugResponse: Boolean = false, is404fine: Boolean = false,
                                                           block: (Request.() -> Request)? = null): Response {
                                    var request = Request(this, "https://api.github.com/repos/${gh.domain}/$relativeUri")
                                        .header("Accept", "application/vnd.github.v3+json")
                                        .header("Authorization", "token ${project.property("${gh.name}Token")!!}")
                                    if (debugRequest)
                                        println(request)
                                    if (block != null)
                                        request = request.block()
                                    return JavaHttpClient()(request).apply {
                                        close()
                                        if (debugResponse)
                                            println(this)
                                        if (!status.successful)
                                            if (status != Status.NOT_FOUND || !is404fine)
                                                error("$status\n$request\n(${request.toCurl()}\n$this")
                                    }
                                }

                                // save commit revision
                                val rev = GET("git/refs/heads").bodyString().sha
                                                                println(rev)

                                // create tmp branch via a reference
//                                POST("git/refs") {
//                                    body("""{"ref": "refs/heads/tmp", "sha": "$rev"}""")
//                                }
//
//                                val repo = project.extensions.getByName<PublishingExtension>("publishing")
//                                    .repositories.first { it.name == gh.name } as MavenArtifactRepository
//                                //                                println(repo)
//
//                                // create/update every file on tmp
//                                val dir = File(repo.url)
//                                dir.walk().forEach { file ->
//                                    if (file.isFile) {
//                                        val path = file.toRelativeString(dir)
//                                        val response = GET("contents/$path", is404fine = true)
//                                        val maybeSha = when (response.status) {
//                                            Status.NOT_FOUND -> ""
//                                            else -> """, "sha": "${response.bodyString().sha}""""
//                                        }
//                                        val content = Base64.getEncoder().encodeToString(file.readBytes())
//                                        PUT("contents/$path") {
//                                            body("""{"path": "$path", "message": "$path", "content": "$content", "branch": "tmp"$maybeSha}""")
//                                        }
//                                    }
//                                }
//
//                                // create the PR
//                                POST("pulls") {
//                                    body("""{"repo":"${gh.repo}","title":"titolo","head":"tmp","base":"master","body":"corpo"}""")
//                                }
//
//                                // retrieve the PR number
//                                val pr = run {
//                                    // retrieve all the PRs (it should be just one) and read its number
//                                    val body = GET("pulls").bodyString()
//                                    val ofs = body.indexOf(""","number":""") + 10
//                                    // let's give it a couple of digits, before parsing
//                                    val number = body.substring(ofs, ofs + 5)
//                                    number.takeWhile { it.isDigit() }.toInt()
//                                }
//
//                                // the current head on `tmp` branch
//                                val lastCommit = run {
//                                    val body = GET("commits/tmp").bodyString()
//                                    val ofs = body.indexOf("\"sha\":\"") + 7
//                                    body.substring(ofs, ofs + 40)
//                                }
//
//                                // we have now everything to merge the PR
//                                PUT("pulls/$pr/merge") {
//                                    body("""{"repo":"${gh.repo}","pull_number":"$pr","commit_title":"org.gradle.sample:library:1.1","sha":"$lastCommit","merge_method":"squash"}""")
//                                }
//
//                                // delete the tmp branch
//                                DELETE("git/refs/heads/tmp")
                            }
                        }
            }
        }
    }

    ////                            doLast {
    ////
    ////                            configured = true
    //                        }
    //            }
    //        }
}

fun Project.putOnTmp(file: File, domain: String, path: String, is404fine: Boolean = false) {
    val token = property("githubToken")!!
    // try to get sha first in case the file already exist (which is mandatory if it's the case)
    val response = GET("https://api.github.com/repos/$domain/contents/$path", token, is404fine = true)
    val maybeSha = when (response.status) {
        Status.NOT_FOUND -> ""
        else -> """, "sha": "${response.bodyString().sha}""""
    }
    val content = Base64.getEncoder().encodeToString(file.readBytes())
    PUT("https://api.github.com/repos/$domain/contents/$path", token) {
        body("""{"path": "$path", "message": "$path", "content": "$content", "branch": "tmp"$maybeSha}""")
    }
}

val String.sha: String
    get() {
        val ofs = indexOf("\"sha\":\"") + 7
        return substring(ofs, ofs + 40)
    }

val Project.token: String
    get() = property("githubToken")!!.toString()

fun Project.getRevision(domain: String): String = GET("https://api.github.com/repos/$domain/git/refs/heads", token).bodyString().sha

fun Project.newRef(domain: String, sha: String): Response =
    POST("https://api.github.com/repos/$domain/git/refs", token) {
        body("""{"ref": "refs/heads/tmp", "sha": "$sha"}""")
    }

fun Project.resetMaster(domain: String, rev: String): Response =
    PATCH("https://api.github.com/repos/$domain/git/refs/master", token) {
        body("""{"sha":"$rev"}""")
    }

fun Project.newPR(domain: String): Response =
    POST("https://api.github.com/repos/$domain/pulls", token) {
        body("""{"repo":"mary","title":"titolo","head":"tmp","base":"master","body":"corpo"}""")
    }

fun Project.prNumber(domain: String): Int {
    val body = listPRs(domain).bodyString()
    val ofs = body.indexOf(""","number":""") + 10
    val number = body.substring(ofs, ofs + 5)
    return number.takeWhile { it.isDigit() }.toInt()
}

fun Project.mergerPR(domain: String, pr: Int, tmpHead: String) {
    println(PUT("https://api.github.com/repos/$domain/pulls/$pr/merge", token) {
        body("""{"repo":"mary","pull_number":"$pr","commit_title":"org.gradle.sample:library:1.1","sha":"$tmpHead","merge_method":"squash"}""")
    })
}

fun Project.getLastTmpCommitID(domain: String): String {
    val body = GET("https://api.github.com/repos/$domain/commits/tmp", token).bodyString()
    val ofs = body.indexOf("\"sha\":\"") + 7
    return body.substring(ofs, ofs + 40)
}

fun Project.listPRs(domain: String): Response = GET("https://api.github.com/repos/$domain/pulls", token)

fun Project.deleteTmp(domain: String): Response = DELETE("https://api.github.com/repos/$domain/git/refs/heads/tmp", token)

operator fun Method.invoke(uri: String, token: Any,
                           debugRequest: Boolean = false, debugResponse: Boolean = false,
                           is404fine: Boolean = false,
                           block: (Request.() -> Request)? = null): Response {
    var request = Request(this, uri)
        .header("Accept", "application/vnd.github.v3+json")
        .header("Authorization", "token $token")
    if (debugRequest)
        println(request)
    if (block != null)
        request = request.block()
    return JavaHttpClient()(request).apply {
        close()
        if (debugResponse)
            println(this)
        if (!status.successful)
            if (status != Status.NOT_FOUND || !is404fine)
                error("$status\n$request\n(${request.toCurl()}\n$this")
    }
}

fun RepositoryHandler.github(block: GithubArtifactRepository.() -> Unit) {
    val gh = GithubArtifactRepository()
    gh.url = configuringProject.run { uri(layout.buildDirectory.dir("repo")) }
    gh.block()
    githubContainer.get().parameters.repositories.get() += gh
//    githubs += gh
    maven {
        name = gh.name
        url = gh.url
    }
}

class GithubArtifactRepository : ArtifactRepository {

    private var n = "github"

    lateinit var domain: String

    lateinit var url: URI

    internal val repo: String
        get() = domain.substringAfter('/')

    override fun getName(): String = n

    override fun setName(name: String) {
        n = name
    }

    override fun content(configureAction: Action<in RepositoryContentDescriptor>) {
        TODO("Not yet implemented")
    }
}

//private operator fun <T> Lazy<T>.setValue(githubArtifactRepository: GithubArtifactRepository, property: KProperty<*>, t: T) {
//    TODO("Not yet implemented")
//}
//
//private operator fun ReadWriteProperty<GithubArtifactRepository, URI>.setValue(t: GithubArtifactRepository, property: KProperty<*>, v: URI) {
//    TODO("Not yet implemented")
//}

//fun MavenPublication.set