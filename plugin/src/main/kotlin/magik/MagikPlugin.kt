/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package magik

import org.gradle.api.Action
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.dsl.RepositoryHandler
import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.MavenArtifactRepository
import org.gradle.api.artifacts.repositories.RepositoryContentDescriptor
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.maven.MavenPublication
import org.gradle.kotlin.dsl.getByName
import org.gradle.kotlin.dsl.maven
import org.http4k.client.JavaHttpClient
import org.http4k.core.*
import org.http4k.core.Method.*
import java.io.File
import java.net.URI
import java.util.*


//abstract class MagikPluginExtension(var repo: File)

//abstract class GithubContainer : BuildService<GithubContainer.Params>, AutoCloseable {
//
//    internal interface Params : BuildServiceParameters {
//        val repositories: Property<ArrayList<GithubArtifactRepository>>
//    }
//
//    init {
//        parameters.repositories.set(ObjectFactory.listProperty())
//    }
//}

//lateinit var githubContainer: Provider<GithubContainer>

// reference in order to loop and detect automatically the publishing task to append logic to
val githubs = ArrayList<GithubArtifactRepository>()

// project reference in order to automatically set as default, a `repo` directory in the build one
lateinit var configuringProject: Project

/**
 * A simple 'hello world' plugin.
 */
class MagikPlugin : Plugin<Project> {

    override fun apply(project: Project) {

        //                println(project)

        // Register the service
        //        githubContainer = project.gradle.sharedServices.registerIfAbsent("githubContainer", GithubContainer::class.java) {}

        configuringProject = project

        // we need to clear once at begin of the parsing, otherwise repos will continue gets added over and over again
        //        if (project.displayName.startsWith("root project '"))
        githubs.clear()

        // Add the 'greeting' extension object
        //        project.extensions.create<MagikPluginExtension>("magik", project.layout.buildDirectory.dir("repo").get().asFile)

        // Register a task
        project.tasks.register("greeting") {
            doLast {
                println("Hello from plugin 'magik.greeting'")
            }
        }

        //        println(project.tasks.rules.size)
        //        println(githubs.size)
        project.tasks.addRule("rule") {
            //                        println("addRule, $this")
            //            println(githubContainer.get())
            project.tasks.all {
                if (name.startsWith("publish"))
                    for (gh in githubs) {
                        //                        println(githubs.size)
                        val postFix = "PublicationTo${gh.name.capitalize()}Repository"
                        if (name.endsWith(postFix)) {
//                            println("$this, $name")
                            doLast {
                                //                                println(project.displayName)

                                operator fun Method.invoke(relativeUri: String, debugRequest: Boolean = false,
                                                           debugResponse: Boolean = false, is404fine: Boolean = false,
                                                           block: (Request.() -> Request)? = null): Response {
                                    var request = Request(this, "https://api.github.com/repos/${gh.domain}/$relativeUri")
                                        .header("Accept", "application/vnd.github.v3+json")
                                        .header("Authorization", "token ${project.property("${gh.name}Token")!!}")
                                    if (debugRequest)
                                        println(request)
                                    if (block != null)
                                        request = request.block()
                                    return JavaHttpClient()(request).apply {
                                        close()
                                        if (debugResponse)
                                            println(this)
                                        if (!status.successful)
                                            if (status != Status.NOT_FOUND || !is404fine)
                                                error("$status\n$request\n(${request.toCurl()}\n$this")
                                    }
                                }

                                // save commit revision
                                val rev = GET("git/refs/heads").bodyString().sha
//                                println(rev)

                                // create tmp branch via a reference
                                POST("git/refs") {
                                    body("""{"ref": "refs/heads/tmp", "sha": "$rev"}""")
                                }

                                val ext = project.extensions.getByName<PublishingExtension>("publishing")
                                val repo = ext.repositories.first { it.name.equals(gh.name, ignoreCase = true) } as MavenArtifactRepository

                                // create/update every file on tmp
                                val dir = File(repo.url)
                                dir.walk().forEach { file ->
                                    if (file.isFile) {
                                        val path = file.toRelativeString(dir)
                                        val response = GET("contents/$path", is404fine = true)
                                        val maybeSha = when (response.status) {
                                            Status.NOT_FOUND -> ""
                                            else -> """, "sha": "${response.bodyString().sha}""""
                                        }
                                        val content = Base64.getEncoder().encodeToString(file.readBytes())
                                        PUT("contents/$path") {
                                            body("""{"path": "$path", "message": "$path", "content": "$content", "branch": "tmp"$maybeSha}""")
                                        }
                                    }
                                }

                                val publ = ext.publications.first {
                                    it.name.equals(name.substringAfter("publish").substringBefore(postFix), ignoreCase = true)
                                } as MavenPublication
                                val gav = "${publ.groupId}:${publ.artifactId}:${publ.version}"

                                // create the PR
                                POST("pulls") {
                                    body("""{"repo":"${gh.repo}","title":"$gav","head":"tmp","base":"master","body":"$gav"}""")
                                }

                                // retrieve the PR number
                                val pr = run {
                                    // retrieve all the PRs (it should be just one) and read its number
                                    val body = GET("pulls").bodyString()
                                    val ofs = body.indexOf(""","number":""") + 10
                                    // let's give it a couple of digits, before parsing
                                    val number = body.substring(ofs, ofs + 5)
                                    number.takeWhile { it.isDigit() }.toInt()
                                }

                                // the current head on `tmp` branch
                                val lastCommit = run {
                                    val body = GET("commits/tmp").bodyString()
                                    val ofs = body.indexOf("\"sha\":\"") + 7
                                    body.substring(ofs, ofs + 40)
                                }

                                // we have now everything to merge the PR
                                PUT("pulls/$pr/merge") {
                                    body("""{"repo":"${gh.repo}","pull_number":"$pr","commit_title":"$gav","sha":"$lastCommit","merge_method":"squash"}""")
                                }

                                // delete the tmp branch
                                DELETE("git/refs/heads/tmp")
                            }
                        }
                    }
            }
        }
    }
}

val String.sha: String
    get() {
        val ofs = indexOf("\"sha\":\"") + 7
        return substring(ofs, ofs + 40)
    }

/** root repositories scope */
fun RepositoryHandler.github(domain: String) = maven("https://raw.githubusercontent.com/$domain/master")

/** root repositories scope */
fun RepositoryHandler.github(owner: String, repo: String) = maven("https://raw.githubusercontent.com/$owner/$repo/master")

/** publishing/repositories scope */
fun RepositoryHandler.github(block: GithubArtifactRepository.() -> Unit) {
    val gh = GithubArtifactRepository()
    gh.url = configuringProject.run { uri(layout.buildDirectory.dir("repo")) }
    gh.block()
    //    githubContainer.get().parameters.repositories.get() += gh
    githubs += gh
    maven {
        name = gh.name
        url = gh.url
    }
}

class GithubArtifactRepository : ArtifactRepository {

    private var n = "github"

    lateinit var domain: String

    lateinit var url: URI

    internal val repo: String
        get() = domain.substringAfter('/')

    override fun getName(): String = n

    override fun setName(name: String) {
        n = name
    }

    override fun content(configureAction: Action<in RepositoryContentDescriptor>) {
        TODO("Not yet implemented")
    }
}

//private operator fun <T> Lazy<T>.setValue(githubArtifactRepository: GithubArtifactRepository, property: KProperty<*>, t: T) {
//    TODO("Not yet implemented")
//}
//
//private operator fun ReadWriteProperty<GithubArtifactRepository, URI>.setValue(t: GithubArtifactRepository, property: KProperty<*>, v: URI) {
//    TODO("Not yet implemented")
//}=